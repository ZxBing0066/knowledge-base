# 浏览器的整个流程 - 从输入 url 到页面展示

## 输入内容

按下键盘/点击屏幕时浏览器接收输入，浏览器可能进行自动提示等。

涉及到硬件层面键盘和系统通信，系统给浏览器发送输入。

## 回车/点击提示

当输入完成后回车或选择浏览器的链接时，浏览器会解析输入的内容，按照类型进行解析。

-   http 请求
-   file 请求
-   特殊指令
-   搜索引擎

## DNS 查找

DNS - DOMAIN NAME SERVER

浏览器按照输入地址去查找对应的 ip，如果为域名则会按照顺序进行 DNS 解析：

-   浏览器 DNS 缓存命中检查
-   调用系统 DNS 解析，系统 DNS 缓存命中检查
-   进入路由器进行 DNS 解析，路由器 DNS 缓存命中检查
-   ISP DNS 服务器解析，进行 DNS 缓存命中检查
-   DNS 服务器进行递归搜索，尝试查找域名 IP

正常 DNS 服务器都为多地部署，客户端会连到最近的 DNS 服务器进行查找。

其它相关内容：

-   循环 DNS：一个域名可对应多个 IP
-   负载均衡器：域名对应的 IP 将请求分发到多个真实 IP 上
-   地理性 DNS：按照客户端地理位置决定返回的 IP 地址，通过多地部署减少请求延时
-   Anycast：通过路由技术将一个 IP 映射到多个实际 IP

## socket 和 TLS 握手

现代浏览器默认都会发起 HTTPS 请求，拿到 DNS 返回的目标 IP 地址后，浏览器会从 URL 中获取端口号，然后先进行 TCP 握手和 TLS 握手（HTTPS）。

### TCP 三次握手

-   第一次握手：客户端发送请求给服务端
-   第二次握手：服务端收到请求，发送消息给客户端
-   第三次握手：客户端发送请求，确认自己收到消息

三次握手的原因：主要由于 TCP 的可靠传输特性，为了确认是否能够进行可靠传输，需要确认服务端和客户端是否都能够正常发送和接收消息：

-   第一次握手时确认了客户端的发送能力
-   第二次握手确认了服务端的接收和发送能力
-   第三次握手确认了客户端的接收能力

### TLS 握手

TLS 1.3 之前使用 RSA 密钥交换算法：

-   客户端发送 client hello 消息给服务端，携带了客户端支持的协议版本、加密算法、压缩算法和一串客户端随机数
-   服务端收到客户端消息和信息后向客户端发送 SSL 证书、选定的协议版本、加密方法和一串服务端随机数，`消息使用 CA 机构发行的证书进行加密`？
-   客户端收到服务端消息后，通过客户端的 CA 机构的公钥（均为受信任机构，公钥放在操作系统或浏览器中）验证服务端证书并取出服务器发来的证书中的公钥信息，
    然后发送一串随机字符串（预主密钥），消息使用服务器公钥加密。
-   服务端接收到消息后，使用证书私钥进行解密，得到预主密钥。
-   客户端和服务端此时均拿到客户端随机数、服务端随机数、预主密钥，通过三个字符传生成会话密钥
-   客户端发送 finished 消息，使用会话密钥进行加密
-   服务端发送 finished 消息，使用会话密钥进行加密
-   完成握手，后续消息使用会话密钥进行对称加密

TLS 1.3 后：

-   客户端发送 hello 消息，包含协议版本、客户端随机数、密码套件列表。还包含了计算预主密钥的参数。
-   服务端通过接收到的客户端随机数、客户端参数、密码套件，生成服务端随机数，然后通过客户端随机数和服务端随机数生成主密钥。
-   服务端给客户端发送服务器证书、数字签名、服务器随机数和密码套件，并发送完成消息。
-   客户端验证签名和证书，生成主密钥，发送完成消息

ECDH 算法：

-   EC 即椭圆曲线，有个特性，在曲线上找出一个点 P，给定一个整数 K，求解 Q=KP 很容易，而如果知道 Q，求解 K 却很难。
-   TLS 1.3 通过 EC 的特性，将随机数通过数字加密传输，保证客户端和服务端随机数的安全性

1.3 后由于减少了不安全的密码套件列表，减少了握手的总长度。？

TLS 握手一定程度上会导致速度变慢。

RSA 不安全的原因：

-   随机数并无法完全随机
-   通过质数和公约数等计算会大大降低破解难度？

## HTTP 请求

协商完成后通过对称加密进行 HTTP 请求，请求到达 HTTP 服务器，服务器将 HTML 写入响应。

## 解析渲染

客户端收到 HTML 后进行浏览器解析，渲染，样式、脚本资源加载 等。

### 浏览器上层架构

![picture 1](/img/flow-02b6477c9a70969b0a228649cdc6d835816c593d6f15ef27407f666049c4d98d.png)

浏览器主要分为以下几部分：

-   UI：包括地址栏、后退/前进按钮、书签菜单等。浏览器显示的每一个部分，除了你看到请求的页面的窗口。
-   UI 后端：用于绘制基本部件，如组合框和窗口。这个后端提供了不针对平台的通用接口。使用操作系统的 UI 方法绘制。
-   浏览器主引擎： Marshals UI 和渲染引擎之间的动作。
-   渲染引擎：负责显示请求的内容。例如，渲染引擎解析 HTML 和 CSS，并在屏幕上显示解析后的内容。（webkit）
-   网络：对于网络调用，如 HTTP 请求，为不同的平台使用不同的实现（在一个平台独立的接口后面）。
-   JavaScript 引擎：用于解析和执行 JavaScript 代码的解释器。（v8）
-   数据存储：这是一个持久性层。浏览器可能需要将数据保存在本地，例如 cookie。浏览器也支持存储机制，如 localStorage、IndexedDB 和 FileSystem。

-   主进程
    -   协调控制其它进程
    -   浏览器 UI 的展示
    -   请求、文件访问、存储
-   渲染进程
    -   页面渲染线程
    -   脚本执行线程
    -   时间循环线程
    -   io 线程
        -   网络
        -   键盘、鼠标
        -   定时器

### 浏览器解析流程

-   浏览器读取 HTML 字符串，按照编码转换为字符
-   按照 html 标准转换字符串
-   对标签进行词法分析
-   转换为 DOM

### 渲染流程

-   渲染引擎接收 html 和 css，进行渲染
-   渲染引擎均为单线程

webkit 渲染流程

![picture 2](/img/flow-33073395a3ad2a3caf19a02a05346431b159e1383afe9469dcf606d18fe79811.png)

-   生成 DOM 树
-   生成 CSS 规则树 CSSOM
-   生成渲染树
-   布局、绘制、展示

### 渲染树和 DOM 树

渲染树由 DOM 树和 CSS 规则树组合生成，包含元素的渲染信息，一般为一些矩形包含层级信息、大小信息、颜色等。

### 布局

-   从上到下，从左到右，计算几何形状
-   每个节点进行 dirty 和 children dirty 标识，来判定是否需要重排

## 请求结束

TCP 四次挥手

## 扩展内容

-   网络传输
    -   局域网
    -   交换机
    -   路由器
    -   网络 7 层协议

## 参考资料

-   https://github.com/vasanthk/how-web-works
-   https://www.cloudflare.com/zh-cn/learning/ssl/what-happens-in-a-tls-handshake/
-   https://blog.csdn.net/zk3326312/article/details/80245756
-   https://en.wikipedia.org/wiki/Transmission_Control_Protocol
-   https://zhuanlan.zhihu.com/p/102149546
